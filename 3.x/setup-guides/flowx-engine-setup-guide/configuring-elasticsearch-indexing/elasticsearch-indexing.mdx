---
title: Configuring elasticsearch indexing
description: This section provides configuration steps for enabling process instance indexing using the Kafka transport strategy.
---

<Tip>
Before proceeding, it is recommended to familiarize yourself with Elasticsearch and its indexing process by referring to the Intro to Elasticsearch section.
</Tip>

<Card title="Intro to Elasticsearch" href="../../../docs/platform-overview/frameworks-and-standards/event-driven-architecture-frameworks/intro-to-elasticsearch" icon="file">
</Card>


## Configuration updates

[Previous configuration sections remain unchanged...]

## Querying Elasticsearch

To read from multiple indices, queries in Elasticsearch have been updated. The queries now run against an index pattern that identifies multiple indices instead of a single index. The index pattern is derived from the value defined in the configuration property:

`flowx.indexing.processInstance.index-name`

### Search Optimization Guidelines

To optimize your search functionality:

1. **Using Index Patterns**
   - Utilize wildcards in index patterns (e.g., `process_instance-*`) to search across multiple time-based indices
   - Consider using date math expressions for dynamic index patterns (e.g., `process_instance-<{now/d}>`)

2. **Search Query Best Practices**
   - Use term queries for exact matches on keyword fields
   - Use match queries for full-text search on text fields
   - Leverage the nested query type for searching within the `keyIdentifiers` structure
   - Utilize range queries for date-based searches on `dateStarted` and `indexLastUpdatedTime`

3. **Field-Specific Search Examples**:

```json
// Example: Search by process definition name
{
  "query": {
    "match": {
      "processDefinitionName": "your-process-name"
    }
  }
}

// Example: Search by state with exact match
{
  "query": {
    "term": {
      "state.keyword": "COMPLETED"
    }
  }
}

// Example: Search within date range
{
  "query": {
    "range": {
      "dateStarted": {
        "gte": "2023-01-01",
        "lte": "2023-12-31"
      }
    }
  }
}

// Example: Complex search with nested key identifiers
{
  "query": {
    "nested": {
      "path": "keyIdentifiers",
      "query": {
        "bool": {
          "must": [
            { "match": { "keyIdentifiers.key": "customerId" }},
            { "match": { "keyIdentifiers.value": "12345" }}
          ]
        }
      }
    }
  }
}
```

4. **Performance Tips**:
   - Use filters instead of queries when exact matching is needed (filters are cached)
   - Implement pagination using `from` and `size` parameters
   - Consider using search_after for deep pagination scenarios
   - Utilize aggregations for analytics and grouping operations

Example with performance optimizations:

```json
{
  "size": 20,
  "from": 0,
  "query": {
    "bool": {
      "filter": [
        { "term": { "state.keyword": "ACTIVE" }},
        { "range": {
          "dateStarted": {
            "gte": "now-30d/d"
          }
        }}
      ]
    }
  },
  "sort": [
    { "dateStarted": "desc" }
  ]
}
```

[Rest of the document remains unchanged...]