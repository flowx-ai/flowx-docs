---
title: Search data
description: This guide will walk you through the process of setting up and optimizing the Search Data service using a Docker image.
icon: magnifying-glass
---

## Infrastructure prerequisites

Before proceeding, ensure the following components are set up:

* **Redis** - version 6.0 or higher 
* **Kafka** - version 2.8 or higher
* **Elasticsearch** - version 7.11.0 or higher

## Dependencies

* **Kafka**: Used for communication with the engine
* **Elasticsearch**: Used for indexing and searching data
* **Redis**: Used for caching

## Configuration

### Kafka Configuration

Set the following Kafka-related configurations using environment variables:

* `SPRING_KAFKA_BOOTSTRAP_SERVERS`: Address of the Kafka server
* `KAFKA_TOPIC_DATA_SEARCH_IN`: The Kafka topic for the search service requests to the engine
* `KAFKA_TOPIC_DATA_SEARCH_OUT`: Where the engine awaits for the response
* `KAFKA_CONSUMER_THREADS`: Number of Kafka consumer threads

### Elasticsearch configuration

Set the following Elasticsearch-related configurations using environment variables:

* `SPRING_ELASTICSEARCH_REST_URIS` 
* `SPRING_ELASTICSEARCH_REST_DISABLESSL` 
* `SPRING_ELASTICSEARCH_REST_USERNAME`
* `SPRING_ELASTICSEARCH_REST_PASSWORD`
* `SPRING_ELASTICSEARCH_INDEX_SETTINGS_NAME` (default: `process-instance`) Customize the index for Search Data service, similar to the [Process Engine configuration](./flowx-engine-setup-guide/configuring-elasticsearch-indexing/)

```yaml
spring:
  elasticsearch:
    rest:
      uris: http://localhost:9200
      disableSsl: false
      username: ""
      password: ""
    index-settings:
      name: process_instance
```

### Authorization & Access Roles Configuration

Set the following environment variables to connect to the identity management platform:

* `SECURITY_OAUTH2_BASE_SERVER_URL`
* `SECURITY_OAUTH2_CLIENT_CLIENT_ID`
* `SECURITY_OAUTH2_REALM`

### Logging Configuration

Control log levels using these environment variables:

* `LOGGING_LEVEL_ROOT`: For root spring boot microservice logs
* `LOGGING_LEVEL_APP`: For app-level logs

## Search Functionality

### Index Pattern Configuration

Data search in Elasticsearch operates against an index pattern representing multiple indices. The index pattern is derived from the configuration property `spring.elasticsearch.index-settings.name`.

### Search Features

The Search Data service supports the following search capabilities:

1. **Full-text Search**: Search across all text fields in the document
2. **Field-specific Search**: Target specific fields using field names
3. **Nested Object Search**: Search within nested document structures
4. **Boolean Queries**: Combine multiple search conditions using AND, OR, NOT operators
5. **Range Queries**: Search for numeric or date values within specific ranges
6. **Fuzzy Search**: Find results that approximately match the search terms

### Search Optimization Best Practices

1. **Index Optimization**:
   - Use appropriate mapping for fields based on their data types
   - Enable field data only for fields that require sorting
   - Implement index aliases for zero-downtime reindexing

2. **Query Optimization**:
   - Use filter context instead of query context for exact matches
   - Implement pagination for large result sets
   - Utilize scroll API for processing large amounts of data

3. **Performance Considerations**:
   - Keep shards size between 20GB and 40GB
   - Use appropriate number of shards based on your data volume
   - Implement caching strategies for frequent searches

### Example Queries

#### Basic Search Query
Here's an example filter for use in Kibana (generated by data search):

```json
{
  "query": {
    "bool": {
      "adjust_pure_negative": true,
      "boost": 1,
      "must": [
        {
          "nested": {
            "boost": 1,
            "ignore_unmapped": false,
            "path": "keyIdentifiers",
            "query": {
              "bool": {
                "adjust_pure_negative": true,
                "boost": 1,
                "must": [
                  {
                    "match": {
                      "keyIdentifiers.key.keyword": {
                        "auto_generate_synonyms_phrase_query": true,
                        "boost": 1,
                        "fuzzy_transpositions": true,
                        "lenient": false,
                        "max_expansions": 50,
                        "operator": "OR",
                        "prefix_length": 0,
                        "query": "astonishingAttribute",
                        "zero_terms_query": "NONE"
                      }
                    }
                  },
                  {
                    "match": {
                      "keyIdentifiers.originalValue.keyword": {
                        "auto_generate_synonyms_phrase_query": true,
                        "boost": 1,
                        "fuzzy_transpositions": true,
                        "lenient": false,
                        "max_expansions": 50,
                        "operator": "OR",
                        "prefix_length": 0,
                        "query": "OriginalGangsta",
                        "zero_terms_query": "NONE"
                      }
                    }
                  }
                ]
              }
            },
            "score_mode": "none"
          }
        },
        {
          "terms": {
            "boost": 1,
            "processDefinitionName.keyword": [
              "TEST_PORCESS_NAME_0",
              "TEST_PORCESS_NAME_1"
            ]
          }
        }
      ]
    }
  }
}
```

#### Fuzzy Search Query
```json
{
  "query": {
    "fuzzy": {
      "field_name": {
        "value": "searchterm",
        "fuzziness": "AUTO",
        "max_expansions": 50
      }
    }
  }
}
```

### Troubleshooting

Common issues and their solutions:

1. **Slow Queries**:
   - Check the query complexity
   - Verify index optimization
   - Monitor memory usage
   - Review shard configuration

2. **Missing Results**:
   - Verify mapping configuration
   - Check analyzer settings
   - Ensure proper field types
   - Review search term analysis

3. **Performance Issues**:
   - Monitor cluster health
   - Check JVM heap usage
   - Review garbage collection logs
   - Optimize number of shards

<Info>
Kibana is an open-source data visualization and exploration tool designed primarily for Elasticsearch. It serves as the visualization layer for the Elastic Stack, allowing users to interact with their data stored in Elasticsearch to perform various activities such as querying, analyzing, and visualizing data.

For more information about Kibana and its capabilities, visit the [**Kibana official documentation**](https://www.elastic.co/guide/en/kibana/current/index.html). This resource provides in-depth guidance, tutorials, and documentation on how to use Kibana effectively for data visualization, analysis, and dashboard creation.
</Info>